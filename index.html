<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç™¼ç²’å­ - æ±ºç­–åšå¼ˆç‰ˆ v2.9</title>
    <style>
        :root { --bg: #050505; --text: #dcdcdc; --accent: #ff3e3e; --gold: #ffd700; --card-bg: #151515; }
        body { font-family: "Consolas", "Microsoft JhengHei", monospace; background: var(--bg); color: var(--text); margin: 0; padding: 10px; display: flex; flex-direction: column; align-items: center; }
        .hidden { display: none; }
        #game { width: 100%; max-width: 600px; }
        .piece { display: inline-block; width: 44px; height: 44px; line-height: 44px; border: 2px solid #333; border-radius: 50%; margin: 4px; cursor: pointer; background: #1a1a1a; font-weight: bold; font-size: 1.3rem; text-align: center; transition: all 0.2s; user-select: none; }
        .piece.red { color: #ff3333; border-color: #8b0000; text-shadow: 0 0 5px rgba(255, 51, 51, 0.3); }
        .piece.black { color: #bbbbbb; border-color: #444; }
        .piece.selected { border-color: var(--gold); transform: translateY(-8px); box-shadow: 0 5px 15px rgba(255,215,0,0.3); }
        .piece.covered { background: #222; color: #222; border-color: #333; }
        .phase-container { background: var(--card-bg); padding: 15px; border-radius: 12px; margin-bottom: 12px; border: 1px solid #222; text-align: center; }
        .table-area { min-height: 100px; background: #000; border-radius: 15px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; padding: 15px; border: 2px solid #1a1a1a; margin: 10px 0; }
        .card-slot { border-bottom: 1px solid #1a1a1a; padding: 5px; min-height: 80px; position: relative; }
        .pattern-label { position: absolute; top: 0; right: 5px; font-size: 0.6rem; color: var(--gold); background: rgba(0,0,0,0.7); padding: 2px 5px; border-radius: 3px; }
        .score-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 10px; width: 100%; }
        .score-box { background: #111; padding: 8px; border-radius: 8px; text-align: center; border-bottom: 2px solid var(--accent); font-size: 0.8rem; }
        .log { height: 100px; overflow-y: auto; background: #000; font-size: 0.75rem; padding: 8px; color: #00ff41; border: 1px solid #222; text-align: left; }
        button { background: #222; color: #fff; border: 1px solid #444; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-weight: bold; margin: 4px; }
        button.primary { background: var(--accent); border: none; }
        button.super-reset { background: #440000; color: #ff9999; font-size: 0.7rem; width: 100%; margin-top: 15px; border: none; }
    </style>
</head>
<body>
    <div id="lobby">
        <h1 style="color:var(--accent); letter-spacing:8px;">ç™¼ç²’å­</h1>
        <div id="seat-selection" style="margin-top:30px">
            <button id="btn-join-1" onclick="join(1)">P1 (ç•¶å®¶)</button>
            <button id="btn-join-2" onclick="join(2)">P2</button>
            <button id="btn-join-3" onclick="join(3)">P3</button>
            <button id="btn-join-4" onclick="join(4)">P4</button>
        </div>
        <button class="super-reset" onclick="forceCleanDatabase()">ğŸ”¥ çµ‚æ¥µè§£é–ï¼šæ¸…ç©ºé›²ç«¯è³‡æ–™</button>
    </div>

    <div id="game" class="hidden">
        <div class="score-row" id="score-ui"></div>
        <div id="counting-phase" class="phase-container hidden">
            <h3 style="color:var(--gold)">ğŸ² æŒ‡é‹éšæ®µ (ç™¼ç‰Œå‰)</h3>
            <p style="font-size:0.8rem">ç”±ç•¶å®¶ <span id="current-dealer-name" style="color:white">?</span> èµ·ç®—</p>
            <input type="number" id="finger-num" min="0" max="10" value="0" style="width:70px; padding:12px; background:#000; color:#fff; border:1px solid #333; font-size:1.5rem; text-align:center;">
            <button class="primary" onclick="submitFinger()">é€å‡ºæ•¸å­—</button>
        </div>
        <div class="table-area" id="table">
            <div class="card-slot" id="slot-p1"><small>P1</small><span class="pattern-label" id="label-p1"></span><div class="cards"></div></div>
            <div class="card-slot" id="slot-p2"><small>P2</small><span class="pattern-label" id="label-p2"></span><div class="cards"></div></div>
            <div class="card-slot" id="slot-p3"><small>P3</small><span class="pattern-label" id="label-p3"></span><div class="cards"></div></div>
            <div class="card-slot" id="slot-p4"><small>P4</small><span class="pattern-label" id="label-p4"></span><div class="cards"></div></div>
        </div>
        <div id="action-ui" class="phase-container">
            <div id="pattern-hint" style="color:var(--gold); font-size:0.9rem; margin-bottom:10px; height:20px;"></div>
            <div id="control-buttons">
                <button id="btn-head-play" class="primary hidden" onclick="headPlay()">æŠ•æ”¾è“‹ç‰Œç²’å­</button>
                <button id="btn-head-reveal" class="primary hidden" onclick="headReveal()">æ€é–‹æˆ‘çš„ç²’å­</button>
                <button id="btn-follow-play" class="primary hidden" onclick="followPlay()">æŠ•æ”¾è“‹ç‰Œç²’å­</button>
                <button id="btn-reveal-yes" class="primary hidden" onclick="revealDecision(true)">é–‹ç‰ŒæŒ‘æˆ°</button>
                <button id="btn-reveal-no" class="hidden" onclick="revealDecision(false)">æ‚¶ç‰Œ Pass</button>
            </div>
            <div id="follow-info" class="hidden" style="font-size:0.8rem; margin-top:5px; color:#888;">éœ€è·Ÿç‰Œæ•¸ï¼š<span id="need-count">0</span></div>
        </div>
        <div class="phase-container">
            <div id="my-hand" style="margin-top:10px"></div>
            <div style="margin-top:15px">
                <button class="sort-btn" onclick="sortHand('rank')">å¤§å°</button>
                <button class="sort-btn" onclick="sortHand('pattern')">ç‰Œå‹</button>
            </div>
            <button id="btn-reset" class="hidden" onclick="initRound()" style="margin-top:10px; width:100%; border-color:var(--accent);">ä¸€å‰¯ç‰Œçµ‚äº†ï¼šé‡å•ŸæŒ‡é‹</button>
            <button class="super-reset" onclick="forceCleanDatabase()">ğŸ”¥ çµ‚æ¥µè§£é–</button>
        </div>
        <div class="log" id="log"></div>
    </div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
    import { getDatabase, ref, set, onValue, update, get, remove } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";

    const firebaseConfig = { apiKey: "AIzaSyA15KzswwEHzY_jg2RvFV0T_CAD19EX7MY", authDomain: "hualiaba.firebaseapp.com", databaseURL: "https://hualiaba-default-rtdb.firebaseio.com", projectId: "hualiaba", appId: "1:1066537441904:web:1b5d1c5e4d1b987eb072b5" };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const gameRef = ref(db, 'room1');
    const seatsRef = ref(db, 'room1/seats');
    let myID, myHand = [], selectedIdx = [], gameState = {}, currentDetectedPattern = "éç‰Œå‹";
    const rankMap = { "ç´…å¸¥":7, "ç´…ä»•":6, "ç´…ç›¸":5, "ç´…ä¿¥":4, "ç´…å‚Œ":3, "ç´…ç‚®":2, "ç´…å…µ":1, "é»‘å°‡":6.5, "é»‘å£«":5.5, "é»‘è±¡":4.5, "é»‘è»Š":3.5, "é»‘é¦¬":2.5, "é»‘åŒ…":1.5, "é»‘å’":0.5 };

    window.join = async (id) => {
        const snap = await get(ref(db, `room1/seats/p${id}`));
        if (snap.exists() && snap.val() === true) return alert("ä½ç½®å·²æ»¿ï¼");
        myID = `p${id}`; await update(seatsRef, { [myID]: true });
        document.getElementById('lobby').classList.add('hidden');
        document.getElementById('game').classList.remove('hidden');
        window.onbeforeunload = () => { update(seatsRef, { [myID]: null }); };
    };

    window.forceCleanDatabase = () => {
        if(confirm("ç¢ºå®šæ¸…ç©ºé›²ç«¯è³‡æ–™ï¼Ÿ")) remove(gameRef).then(() => location.reload());
    };

    window.initRound = () => {
        update(gameRef, { phase: "COUNTING", table: null, finger_picks: {}, p1_hand: [], p2_hand: [], p3_hand: [], p4_hand: [] });
    };

    onValue(gameRef, (snap) => {
        const d = snap.val(); if(!d) return;
        gameState = d; if (!gameState.dealer) gameState.dealer = "p1";
        myHand = d[`${myID}_hand`] || [];
        updateUI();
    });

    function updateUI() {
        const scores = gameState.scores || {p1:0, p2:0, p3:0, p4:0};
        document.getElementById('score-ui').innerHTML = [1,2,3,4].map(i => {
            const s = scores[`p${i}`], final = s + (s >= 32 ? 10 : 0);
            return `<div class="score-box">P${i}<br><b>${final}</b><br><small>${final-80>=0?'+'+(final-80):final-80}</small></div>`;
        }).join('');

        document.getElementById('current-dealer-name').innerText = gameState.dealer;
        const ph = gameState.phase, isH = (myID === gameState.head), hasP = (gameState.table && gameState.table[myID]);
        
        document.getElementById('counting-phase').className = ph === "COUNTING" ? "phase-container" : "hidden";
        if(ph === "COUNTING" && Object.keys(gameState.finger_picks || {}).length === 4 && myID === (gameState.dealer || "p1")) resolveHeadAndDeal();

        const handDiv = document.getElementById('my-hand');
        handDiv.innerHTML = myHand.map((p, i) => `<div class="piece ${p.includes('ç´…')?'red':'black'} ${selectedIdx.includes(i)?'selected':''}" onclick="togglePiece(${i})">${p[1]}</div>`).join('');

        [1,2,3,4].forEach(i => {
            const slot = document.querySelector(`#slot-p${i} .cards`);
            const label = document.getElementById(`label-p${i}`);
            const pData = (gameState.table || {})[`p${i}`];
            slot.innerHTML = pData ? pData.cards.map(c => (pData.revealed || i == myID.slice(1)) ? `<div class="piece ${c.includes('ç´…')?'red':'black'}">${c[1]}</div>` : `<div class="piece covered">?</div>`).join('') : "";
            label.innerText = (pData && pData.declared) ? pData.declared : "";
        });

        // æŒ‰éˆ•æ§åˆ¶é‚è¼¯æ›´æ–°
        document.getElementById('btn-head-play').className = (ph === "HEAD_PLAYING" && isH) ? "primary" : "hidden";
        document.getElementById('btn-head-reveal').className = (ph === "HEAD_REVEALING" && isH) ? "primary" : "hidden";
        document.getElementById('btn-follow-play').className = (ph === "FOLLOW_PLAYING" && !isH && !hasP) ? "primary" : "hidden";
        
        // é—œéµä¿®æ­£ï¼šåªæœ‰åœ¨é ­å®¶ç¿»ç‰Œå¾Œï¼Œè·Ÿå®¶æ‰èƒ½æ±ºå®šæŒ‘æˆ°æˆ– Pass
        document.getElementById('btn-reveal-yes').className = (ph === "REVEAL_DECISION" && !isH && hasP && gameState.table[myID].decision === "pending") ? "primary" : "hidden";
        document.getElementById('btn-reveal-no').className = (ph === "REVEAL_DECISION" && !isH && hasP && gameState.table[myID].decision === "pending") ? "" : "hidden";
        
        const allEmpty = (gameState.p1_hand||[]).length===0 && (gameState.p2_hand||[]).length===0 && (gameState.p3_hand||[]).length===0 && (gameState.p4_hand||[]).length===0;
        document.getElementById('btn-reset').className = (allEmpty && ph !== "COUNTING" && myID === (gameState.dealer || "p1")) ? "primary" : "hidden";

        if(ph === "FOLLOW_PLAYING") document.getElementById('need-count').innerText = gameState.table[gameState.head].cards.length;
        document.getElementById('log').innerHTML = (gameState.logs || []).reverse().map(l => `<div>> ${l}</div>`).join('');
        detectPattern();
    }

    function detectPattern() {
        const hintEl = document.getElementById('pattern-hint');
        if(selectedIdx.length === 0) { hintEl.innerText = ""; currentDetectedPattern = "éç‰Œå‹"; return; }
        const sel = selectedIdx.map(i => myHand[i]), count = sel.length, names = sel.map(s => s[1]).sort().join('');
        let h = "éç‰Œå‹";
        if(count === 1) h = "ä¸€é¡†";
        else if(count === 2 && sel[0][1] === sel[1][1] && sel[0][0] === sel[1][0]) h = "ä¸€å°";
        else if(count === 3 && (names==="ä»•å¸¥ç›¸" || names==="å£«å°‡è±¡" || names==="å‚Œä¿¥ç‚®" || names==="åŒ…è»Šé¦¬")) h = "ä¸€å±€";
        else if(count >= 3 && sel.every(s => s[1]==="å…µ" || s[1]==="å’")) h = "å…µå’çµ„";
        hintEl.innerText = `ç‰Œå‹é åˆ¤ï¼š${h}`;
        currentDetectedPattern = h;
        document.getElementById('btn-head-play').disabled = (h === "éç‰Œå‹");
    }

    window.togglePiece = (i) => { const idx = selectedIdx.indexOf(i); if(idx > -1) selectedIdx.splice(idx, 1); else selectedIdx.push(i); updateUI(); };
    window.sortHand = (t) => {
        if(t === 'rank') myHand.sort((a,b) => rankMap[b] - rankMap[a]);
        else { const o = {"å¸¥":1, "å°‡":1, "ä»•":2, "å£«":2, "ç›¸":3, "è±¡":3, "ä¿¥":4, "è»Š":4, "å‚Œ":5, "é¦¬":5, "ç‚®":6, "åŒ…":6, "å…µ":7, "å’":7}; myHand.sort((a,b) => (o[a[1]] || 99) - (o[b[1]] || 99) || a[0].localeCompare(b[0])); }
        update(gameRef, { [`${myID}_hand`]: myHand });
    };

    window.submitFinger = () => { update(gameRef, { [`finger_picks/${myID}`]: parseInt(document.getElementById('finger-num').value) }); };

    function resolveHeadAndDeal() {
        const sum = Object.values(gameState.finger_picks).reduce((a,b) => a+b, 0);
        const headIdx = (parseInt(gameState.dealer.slice(1)) - 1 + sum - 1) % 4;
        const headID = `p${headIdx + 1}`;
        const p = ["ç´…å¸¥","ç´…ä»•","ç´…ä»•","ç´…ç›¸","ç´…ç›¸","ç´…ä¿¥","ç´…ä¿¥","ç´…å‚Œ","ç´…å‚Œ","ç´…ç‚®","ç´…ç‚®","ç´…å…µ","ç´…å…µ","ç´…å…µ","ç´…å…µ","ç´…å…µ","é»‘å°‡","é»‘å£«","é»‘å£«","é»‘è±¡","é»‘è±¡","é»‘è»Š","é»‘è»Š","é»‘é¦¬","é»‘é¦¬","é»‘åŒ…","é»‘åŒ…","é»‘å’","é»‘å’","é»‘å’","é»‘å’","é»‘å’"];
        const s = p.sort(() => Math.random() - 0.5);
        update(gameRef, { phase: "HEAD_PLAYING", head: headID, logs: [...gameState.logs, `æŒ‡é‹ç¸½å’Œ ${sum}ã€‚é ­å®¶ï¼š${headID}`], p1_hand: s.slice(0, 8), p2_hand: s.slice(8, 16), p3_hand: s.slice(16, 24), p4_hand: s.slice(24, 32) });
    }

    window.headPlay = () => {
        const c = selectedIdx.map(i => myHand[i]);
        update(gameRef, { 
            phase: "FOLLOW_PLAYING", 
            [`table/${myID}`]: { cards: c, revealed: false, declared: currentDetectedPattern, decision: "reveal" }, 
            [`${myID}_hand`]: myHand.filter((_, i) => !selectedIdx.includes(i)), 
            logs: [...gameState.logs, `${myID} æŠ•æ”¾ç²’å­ (å®£å‘Š: ${currentDetectedPattern})`] 
        });
        selectedIdx = [];
    };

    window.followPlay = () => {
        const count = gameState.table[gameState.head].cards.length;
        if(selectedIdx.length !== count) return alert(`éœ€è·ŸæŠ• ${count} é¡†ï¼`);
        update(gameRef, { 
            [`table/${myID}`]: { cards: selectedIdx.map(i => myHand[i]), revealed: false, decision: "pending" }, 
            [`${myID}_hand`]: myHand.filter((_, i) => !selectedIdx.includes(i)) 
        }).then(() => {
            get(gameRef).then(s => {
                const d = s.val(); if(d.table.p1 && d.table.p2 && d.table.p3 && d.table.p4) {
                    update(gameRef, { phase: "HEAD_REVEALING", logs: [...d.logs, "å…¨å“¡æŠ•å®Œã€‚è«‹é ­å®¶æ€ç‰Œã€‚"]});
                }
            });
        });
        selectedIdx = [];
    };

    window.headReveal = () => { update(gameRef, { phase: "REVEAL_DECISION", [`table/${gameState.head}/revealed`]: true, logs: [...gameState.logs, "é ­å®¶å·²æ€ç‰Œã€‚è«‹è·Ÿå®¶æ±ºå®šæŒ‘æˆ°æˆ– Passã€‚"]}); };

    // æ–°å¢ï¼šè·Ÿå®¶çš„æ€ç‰Œæ±ºç­–
    window.revealDecision = (res) => {
        update(gameRef, { 
            [`table/${myID}/decision`]: res ? "reveal" : "muffle",
            [`table/${myID}/revealed`]: res ? true : false
        }).then(() => {
            get(gameRef).then(s => {
                const d = s.val(); let decidedCount = 0; 
                [1,2,3,4].forEach(i => { if(d.table[`p${i}`] && d.table[`p${i}`].decision !== "pending") decidedCount++; });
                if(decidedCount === 4) resolveWinner(d);
            });
        });
    };

    function resolveWinner(d) {
        let win = d.head, max = -1;
        const getP = (cards) => {
            const ns = cards.map(c => c[1]).sort().join(''), isR = cards.every(c => c.includes('ç´…'));
            if (ns === "ä»•å¸¥ç›¸" || ns === "å£«å°‡è±¡") return isR ? 100 : 95; if (ns === "å‚Œä¿¥ç‚®" || ns === "åŒ…è»Šé¦¬") return isR ? 85 : 80;
            if (cards.length >= 3 && cards.every(c => c[1] === "å…µ" || c[1] === "å’")) return 50 + cards.length;
            if (cards.length === 2 && cards[0][1] === cards[1][1] && cards[0][0] === cards[1][0]) return 40 + rankMap[cards[0]];
            return Math.max(...cards.map(c => rankMap[c]));
        };
        [1,2,3,4].forEach(i => {
            const p = d.table[`p${i}`];
            // åªæœ‰é¸æ“‡ reveal (æŒ‘æˆ°) çš„äººæ‰èƒ½åƒèˆ‡æ¯”å¤§å°
            if(p && p.decision === "reveal") { 
                const pw = getP(p.cards); 
                if(pw > max) { max = pw; win = `p${i}`; } 
            }
        });
        const pts = d.table[d.head].cards.length * 4; const ns = {...d.scores}; ns[win] += pts;
        const dealerOrder = { "p1": "p2", "p2": "p3", "p3": "p4", "p4": "p1" };
        setTimeout(() => { 
            const updates = { phase: "HEAD_PLAYING", head: win, table: null, scores: ns, logs: [...d.logs, `${win} å¥ªå¾—æœ¬è¼ª ${pts} åˆ†ï¼`] };
            if (myHand.length === 0) { updates.dealer = dealerOrder[gameState.dealer || "p1"]; updates.phase = "FINISHED"; }
            update(gameRef, updates); 
        }, 1500);
    }
</script>
</body>
</html>
